import socket
import fcntl
import struct
import psutil
from arprequest import ArpRequest as arp

class scan:
    def __init__(self, name) -> None:
        self.name = name  # type: str
        self.ports = []

    def run(self):
        banners = []
        failedConnections = []

        # loop through network interfaces
        for netInterface in psutil.net_if_stats().keys():
            network = subnet(netInterface)

            # get ips and then scan each one
            ipList = network.ipHosts()
            for ip in ipList:
                # go through all the ports being scanned
                for port in self.ports:
                    try:
                        banners.append(getBanner(ip, port))
                    except:
                        failedConnections.append([ip, port])



        '''
        converted_ip = '13.87.64.140'  # 10.206.16.1
        port = 443
        sock = socket.socket()
        sock.settimeout(0.5)
        sock.connect((converted_ip, port))
        # self.open_ports.append(port)
        banner = sock.recv(1024).decode().strip('\n').strip('\r')
        testing = open('presets.txt', 'r+')
        testing.write(banner)
        '''


class subnet():
    def __init__(self, netInterface):

        # getting subnet mask using socket
        udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.subnetMask = socket.inet_ntoa(fcntl.ioctl(udpSock.fileno(), 0x891b, struct.pack('256s', bytes(netInterface,'utf-8')[:15]))[20:24])
        udpSock.close()

        # get network address:

        ipOctets = socket.gethostbyname(socket.gethostname()).split(".")
        subnetOctets = self.subnetMask.split(".")

        self.networkAddressOctets = []
        for i in range(4):
            self.networkAddressOctets.append(int(ipOctets[i]) & int(subnetOctets[i]))

        # get number of hosts:
        binarySubnetMask = []
        # converts subnet mask to binary
        for octet in [bin(int(subnetMaskOctet)).removeprefix("0b") for subnetMaskOctet in self.subnetMask.split(".")]:
            binarySubnetMask.append("0" * (8 - len(octet)) + octet)

        # the binary subnet mask is mapped onto a function that counts the 0s of each octet, all the octet 0's are then
        # summed up into the bitNum variable.
        bitNum = sum(map(lambda string: string.count("0"), binarySubnetMask))

        # the number of hosts is equal to 2 to the number of bits, -2 for the network address and broadcast address
        self.numberOfHosts = 2 ** bitNum - 2

        # get slashNotation
        self.slashNotation = 32 - bitNum

    def ipHosts(self):
        ipList = []
        if self.slashNotation <= 8:
            for i in range(self.numberOfHosts):
                pass
                #ipList.append(str(self.networkAddressOctets[0] + i) + ".".join(self.networkAddressOctets[1:3]))
        elif self.slashNotation <= 16:
            for i in range(self.numberOfHosts):
                pass
        elif self.slashNotation <= 24:
            for i in range(self.numberOfHosts):
                pass
        elif self.slashNotation <= 32:
            for i in range(self.numberOfHosts):
                pass
        return ipList

class cpe:
    def __init__(self) -> None:
        self.cpe = None
        self.cves = []

    def cpeFromBanner(self, banner):
        self.cpe = None


class cve:
    def __init__(self) -> None:
        self.cvss = 0  # type: float
        self.cvssVector = ""
        self.description = ""  # type: str
        self.cweID = 0  # type: int
        self.cweDescription = ""  # type: str

    def __deriveCvss(self, cvssVector):
        # using the cvss vector, calculate the cvss
        return None

def getBanner(ip, port):
    sock = socket.socket()
    sock.settimeout(0.5)
    sock.connect((ip, port))
    return sock.recv(1024).decode().strip('\n').strip('\r')
