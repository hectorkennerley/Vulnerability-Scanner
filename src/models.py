import socket
import subprocess
import psutil
from arprequest import ArpRequest as arp

class scan:
    def __init__(self, name, ports) -> None:
        self.name = name  # type: str
        self.ports = ports

    def run(self):
        banners = []
        failedConnections = []

        # loop through network interfaces
        for netInterface in psutil.net_if_stats().keys():
            network = subnet(netInterface)

            # get ips and then scan each one
            ipList = network.ipHosts()
            for ip in ipList:
                # go through all the ports being scanned
                for port in self.ports:
                    try:
                        banners.append(getBanner(ip, port))
                    except:
                        failedConnections.append([ip, port])
        return banners, failedConnections


class subnet():
    def __init__(self, netInterface):
        # getting subnet mask using socket
        print(netInterface)
        try:
            addrs = psutil.net_if_addrs()
            if netInterface in addrs:
                for addr in addrs[netInterface]:
                    if addr.family == psutil.AF_INET:
                        self.subnetMask = addr.netmask
        except:
            print("error getting subnetMask")

        # get network address:

        ipOctets = socket.gethostbyname(socket.gethostname()).split(".")
        subnetOctets = self.subnetMask.split(".")

        self.networkAddressOctets = []
        for i in range(4):
            self.networkAddressOctets.append(int(ipOctets[i]) & int(subnetOctets[i]))

        # get number of hosts:
        binarySubnetMask = []
        # converts subnet mask to binary
        for octet in [bin(int(subnetMaskOctet)).removeprefix("0b") for subnetMaskOctet in self.subnetMask.split(".")]:
            binarySubnetMask.append("0" * (8 - len(octet)) + octet)

        # the binary subnet mask is mapped onto a function that counts the 0s of each octet, all the octet 0's are then
        # summed up into the bitNum variable.
        bitNum = sum(map(lambda string: string.count("0"), binarySubnetMask))

        # the number of hosts is equal to 2 to the number of bits, -2 for the network address and broadcast address
        self.numberOfHosts = 2 ** bitNum - 2

        # get slashNotation
        self.slashNotation = 32 - bitNum

    def ipHosts(self):
        ipList = []
        if self.slashNotation <= 8:
            for i in range(self.numberOfHosts):
                pass
                #ipList.append(str(self.networkAddressOctets[0] + i) + ".".join(self.networkAddressOctets[1:3]))
        elif self.slashNotation <= 16:
            for i in range(self.numberOfHosts):
                pass
        elif self.slashNotation <= 24:
            for i in range(self.numberOfHosts):
                pass
        elif self.slashNotation <= 32:
            for i in range(self.numberOfHosts):
                pass
        return ipList

class cpe:
    def __init__(self) -> None:
        self.cpe = None
        self.cves = []

    def cpeFromBanner(self, banner):
        self.cpe = None


class cve:
    def __init__(self) -> None:
        self.cvss = 0  # type: float
        self.cvssVector = ""
        self.description = ""  # type: str
        self.cweID = 0  # type: int
        self.cweDescription = ""  # type: str

    def __deriveCvss(self, cvssVector):
        # using the cvss vector, calculate the cvss
        return None

def getBanner(ip, port):
    sock = socket.socket()
    sock.settimeout(0.5)
    sock.connect((ip, port))
    return sock.recv(1024).decode().strip('\n').strip('\r')


def parsedIpConfig():
    # gets windows command prompt output from the command 'IpConfig' and parses it into a list
    # returns 4D list, format: [["interface name", [["property", "property value"], ...], ...], ...]
    # restricted to: [i][0-1][j][0-1] where i and j can be infinite

    # gets command output using 'subprocess'
    # removing the first 32 characters they're useless
    ipconfig = subprocess.check_output("ipconfig")[32:]
    spaceCount = 0
    blankCount = 0
    interfaceNum = 0
    propertyNum = 0
    propertyPart = 0
    inInterface = True
    startedInterface = True
    exitedInterface = False
    inProperty = False
    startedProperty = False
    propertyFirstPartDotted = False
    parsedOutput = []

    for char in ipconfig:
        char = chr(char)

        # collecting interface name
        if inInterface:
            # create new interface if interface is being started
            if startedInterface:
                parsedOutput.append(["", []])
                startedInterface = False

            # if the character is a colon that is the end of the interface
            if char == ':':
                inInterface = False
                exitedInterface = True
            elif char != '\n':
                # adding character to interface name
                parsedOutput[interfaceNum][0] = parsedOutput[interfaceNum][0] + char

        # collecting property
        elif inProperty:
            exitedInterface = False
            # changes to second part if colon appears
            if char == ':':
                propertyPart = 1
                propertyFirstPartDotted = False
                parsedOutput[interfaceNum][1][propertyNum][0] = parsedOutput[interfaceNum][1][propertyNum][0].strip()
            # starts ignoring first part of property if dot appears
            elif propertyPart == 0 and char == ".":
                propertyFirstPartDotted = True
            elif propertyFirstPartDotted == False and char != "\r" and char != "\n":
                parsedOutput[interfaceNum][1][propertyNum][propertyPart] = parsedOutput[interfaceNum][1][propertyNum][propertyPart] + char
            elif char == "\r" and propertyPart == 1:
                parsedOutput[interfaceNum][1][propertyNum][1] = parsedOutput[interfaceNum][1][propertyNum][1].strip()
                propertyNum += 1
                propertyPart = 0
                inProperty = False

        elif char == ' ':
            spaceCount += 1
            blankCount = 0
            if spaceCount == 3:
                inProperty = True
                # create a property
                parsedOutput[interfaceNum][1].append(["", ""])
                spaceCount = 0

        elif char == '\r':
            blankCount += 1
            if blankCount == 1 and not exitedInterface:
                interfaceNum += 1
                startedInterface = True
                inInterface = True
                propertyNum = 0

    return parsedOutput
