import socket
import subprocess
import ipaddress
import nvdlib
import time


def scan(ports, interfaces, getOS, delay: float = 0, timeOut: float = 0.5):
    # return [{"ip": ip, "port": port, "banner": banner, "OS": OS}, ...]
    # "OS" is optional
    subnetIpData = []

    # loop through network interfaces
    for netInterface in parsedIpConfig():
        subnetMask = None
        if netInterface[0] in interfaces:
            for prop in netInterface[1]:
                if prop[0].lower() == "subnet mask":
                    subnetMask = prop[1]

        if subnetMask != None:
            network = subnet(subnetMask)
            # get ips and then scan each one
            ipList = network.getHostIPs()
            for ip in ipList:
                # go through all the ports being scanned
                ipData = {"ip": ip}
                for port in ports:
                    banner = getBanner(ip, port, timeOut)
                    ipData.update({"port": port, "banner": banner})
                    time.sleep(delay)
                if getOS == True:
                    OS = identifyOS([banner for banner in ipData["banner"]])
                    ipData.update({"OS": OS})
                subnetIpData.append(ipData)
    return subnetIpData


class subnet():
    def __init__(self, subnetMask):
        self._subnetMask = subnetMask

        # get network address:
        ipOctets = socket.gethostbyname(socket.gethostname()).split(".")
        subnetOctets = self._subnetMask.split(".")

        self.networkAddressOctets = []
        for i in range(4):
            self.networkAddressOctets.append(int(ipOctets[i]) & int(subnetOctets[i]))
        self._networkAddress = ".".join([str(octet) for octet in self.networkAddressOctets])

        # get number of hosts:
        binarySubnetMask = []
        # converts subnet mask to binary
        for octet in [bin(int(subnetMaskOctet)).removeprefix("0b") for subnetMaskOctet in self._subnetMask.split(".")]:
            binarySubnetMask.append("0" * (8 - len(octet)) + octet)

        # the binary subnet mask is mapped onto a function that counts the 0s of each octet, all the octet 0's are then
        # summed up into the bitNum variable.
        bitNum = sum(map(lambda string: string.count("0"), binarySubnetMask))

        # the number of hosts is equal to 2 to the number of bits, -2 for the network address and broadcast address
        self._numberOfHosts = 2 ** bitNum - 2

        # get slashNotation
        self._slashNotation = 32 - bitNum


    def getHostIPs(self):
        network = ipaddress.IPv4Network(f"{self._networkAddress}/{self._subnetMask}", strict=False)
        hostIpList = [str(ip) for ip in network.hosts()]
        return hostIpList


class cpe:
    def __init__(self) -> None:
        self.cpe = None
        self.cves = []

    def cpeFromBanner(self, banner):
        self.cpe = None


class cve:
    def __init__(self) -> None:
        self.cvss = 0  # type: float
        self.cvssVector = ""
        self.description = ""  # type: str
        self.cweID = 0  # type: int
        self.cweDescription = ""  # type: str

    def __deriveCvss(self, cvssVector):
        # using the cvss vector, calculate the cvss
        return None

def getBanner(ip, port, timeOut):
    try:
        sock = socket.socket()
        sock.settimeout(timeOut)
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip('\n').strip('\r')
        sock.close()
        return banner
    except:
        return None


def parsedIpConfig():
    # gets windows command prompt output from the command 'IpConfig' and parses it into a list
    # returns 4D list, format: [["interface name", [["property name", "property value", ...], ...], ...], ...]
    # restricted to: [i][0-1][j][t] where i, j and t belong to the natural numbers and t >= 1

    # gets command output using 'subprocess'
    # removes the first 32 characters since they don't contain any useful information
    ipconfig = subprocess.check_output("ipconfig")[32:]
    spaceCount = 0
    blankCount = 0
    interfaceNum = 0
    propertyNum = 0
    propertyPart = 0
    inInterface = True
    startedInterface = True
    exitedInterface = False
    inProperty = False
    propertyFirstPartDotted = False
    propertyStarted = False
    parsedOutput = []

    for char in ipconfig:
        char = chr(char)

        # collecting interface name
        if inInterface:
            # create new interface if interface is being started
            if startedInterface:
                parsedOutput.append(["", []])
                startedInterface = False

            # if the character is a colon that is the end of the interface
            if char == ':':
                inInterface = False
                exitedInterface = True
            elif char != '\n':
                # adding character to interface name
                parsedOutput[interfaceNum][0] = parsedOutput[interfaceNum][0] + char

        # collecting property
        elif inProperty:
            exitedInterface = False
            # incase property has more than one value
            if char == ' ':
                if propertyStarted is True:
                    propertyPart += 1
                    propertyNum -= 1
                    parsedOutput[interfaceNum][1][propertyNum].append("")
            # creates new property
            elif propertyStarted is True:
                propertyPart = 0
                parsedOutput[interfaceNum][1].append(["", ""])
            propertyStarted = False
            # changes to second part if colon appears
            if char == ':':
                propertyPart = 1
                propertyFirstPartDotted = False
                # removes blank space
                parsedOutput[interfaceNum][1][propertyNum][0] = parsedOutput[interfaceNum][1][propertyNum][0].strip()
            # starts ignoring first part of property if dot appears
            elif propertyPart == 0 and char == ".":
                propertyFirstPartDotted = True
            # adds character to property
            elif propertyFirstPartDotted == False and char != "\r" and char != "\n":
                parsedOutput[interfaceNum][1][propertyNum][propertyPart] = parsedOutput[interfaceNum][1][propertyNum][propertyPart] + char
            elif char == "\r" and propertyPart > 0:
                # removes blank space
                parsedOutput[interfaceNum][1][propertyNum][propertyPart] = parsedOutput[interfaceNum][1][propertyNum][propertyPart].strip()
                inProperty = False
                propertyNum += 1

        elif char == ' ':
            spaceCount += 1
            blankCount = 0
            if spaceCount == 3:
                inProperty = True
                propertyStarted = True
                # create a property
                spaceCount = 0

        elif char == '\r':
            blankCount += 1
            if blankCount == 1 and not exitedInterface:
                interfaceNum += 1
                startedInterface = True
                inInterface = True
                propertyNum = 0

    return parsedOutput

def bannerToCpe(banner):
    pass

def createCPE():
    # cpe:<cpe_version>:<part>:<vendor>:<product>:<version>:<update>:<edition>:<language>:<sw_edition>:<target_sw>:<target_hw>:<other>
    try:
        with open("acceptableCPERegularExpression.txt", "r") as doc:
            acceptableCPERegularExpression = doc.readline()
    except FileNotFoundError:
        acceptableCPERegularExpression = False
    return None

def identifyOS(banners):
    with open("OSes.txt", "r") as OSes:
        for os in OSes.readlines():
            for banner in banners:
                if os.lower() in banner.lower():
                    return os
    return False
